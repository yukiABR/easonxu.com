<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>英语词汇星域 · Grade 8 Arcade</title>
  <style>
    :root {
      --bg-0: #060913;
      --bg-1: #0b1530;
      --bg-2: #152a55;
      --line: rgba(146, 181, 255, 0.28);
      --text: #ecf4ff;
      --muted: #a6bbde;
      --card: rgba(12, 20, 43, 0.74);
      --card-strong: rgba(17, 30, 62, 0.88);
      --glow-cyan: #41e8ff;
      --glow-purple: #b08bff;
      --glow-pink: #ff5ebf;
      --good: #3be68a;
      --bad: #ff667a;
      --warn: #ffd36a;
      --shadow: 0 14px 44px rgba(3, 8, 23, 0.52);
      --radius: 18px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      font-family: "STKaiti", "Kaiti SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background:
        radial-gradient(circle at 12% 10%, rgba(65, 232, 255, 0.2), transparent 27%),
        radial-gradient(circle at 86% 12%, rgba(176, 139, 255, 0.2), transparent 26%),
        radial-gradient(circle at 55% 82%, rgba(255, 94, 191, 0.16), transparent 30%),
        linear-gradient(140deg, var(--bg-0), var(--bg-1) 52%, var(--bg-2));
      padding: 16px;
      overflow-x: hidden;
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: -30vh -20vw;
      pointer-events: none;
      z-index: -2;
      background:
        repeating-linear-gradient(128deg,
          transparent 0,
          transparent 22px,
          rgba(144, 188, 255, 0.028) 22px,
          rgba(144, 188, 255, 0.028) 23px);
      animation: drift 22s linear infinite;
    }

    body::after {
      opacity: 0.5;
      transform: scale(1.08);
      filter: blur(1px);
      animation-duration: 30s;
      animation-direction: reverse;
    }

    @keyframes drift {
      from { transform: translate3d(0, 0, 0); }
      to { transform: translate3d(-80px, -80px, 0); }
    }

    .app {
      max-width: 1260px;
      margin: 0 auto;
      display: grid;
      gap: 14px;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: var(--card);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .hero {
      padding: 16px 18px;
      display: flex;
      justify-content: space-between;
      gap: 14px;
      align-items: center;
      flex-wrap: wrap;
      position: relative;
      overflow: hidden;
    }

    .hero::before {
      content: "";
      position: absolute;
      inset: -40% -20%;
      background:
        conic-gradient(from 0deg,
          rgba(65, 232, 255, 0.16),
          rgba(176, 139, 255, 0.1),
          rgba(255, 94, 191, 0.14),
          rgba(65, 232, 255, 0.16));
      animation: spin 18s linear infinite;
      filter: blur(24px);
      z-index: 0;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .hero-main,
    .hero-side {
      position: relative;
      z-index: 1;
    }

    .hero h1 {
      margin: 0;
      font-size: clamp(1.25rem, 2.5vw, 2rem);
      letter-spacing: 0.04em;
      text-shadow: 0 4px 18px rgba(10, 21, 50, 0.56);
    }

    .hero p {
      margin: 7px 0 0;
      color: var(--muted);
      font-size: 0.92rem;
    }

    .pill-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      border: 1px solid rgba(65, 232, 255, 0.52);
      background: rgba(65, 232, 255, 0.12);
      color: var(--glow-cyan);
      padding: 6px 11px;
      border-radius: 999px;
      font-size: 0.83rem;
      font-weight: 700;
      letter-spacing: 0.03em;
    }

    .dashboard {
      padding: 12px;
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 8px;
    }

    .metric {
      border-radius: 12px;
      border: 1px solid rgba(146, 181, 255, 0.26);
      background: rgba(11, 24, 52, 0.75);
      padding: 8px 10px;
      min-height: 70px;
    }

    .metric span {
      display: block;
      font-size: 0.76rem;
      color: var(--muted);
    }

    .metric strong {
      display: block;
      margin-top: 4px;
      font-size: 1.03rem;
      font-family: "Futura", "Trebuchet MS", sans-serif;
      letter-spacing: 0.03em;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 340px minmax(0, 1fr);
      gap: 12px;
      align-items: start;
    }

    .panel-title {
      margin: 0 0 10px;
      font-size: 1rem;
      letter-spacing: 0.04em;
      color: #dff0ff;
    }

    .control {
      padding: 14px;
      display: grid;
      gap: 14px;
    }

    .unit-grid,
    .mode-grid {
      display: grid;
      gap: 8px;
    }

    .unit-grid {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .mode-grid {
      grid-template-columns: 1fr;
    }

    .chip,
    .mode-card,
    .btn {
      border: 1px solid transparent;
      background: rgba(17, 31, 64, 0.88);
      color: var(--text);
      border-radius: 12px;
      padding: 9px 10px;
      cursor: pointer;
      font: inherit;
      transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
    }

    .chip:hover,
    .mode-card:hover,
    .btn:hover {
      transform: translateY(-1px);
      border-color: rgba(129, 167, 255, 0.54);
      box-shadow: 0 10px 18px rgba(5, 11, 29, 0.42);
    }

    .chip.active {
      border-color: rgba(65, 232, 255, 0.78);
      background: rgba(46, 106, 157, 0.34);
      box-shadow: 0 0 0 1px rgba(65, 232, 255, 0.5) inset;
    }

    .mode-card {
      text-align: left;
      border-color: rgba(146, 181, 255, 0.3);
      background: linear-gradient(145deg, rgba(20, 34, 68, 0.94), rgba(11, 24, 50, 0.9));
    }

    .mode-card strong {
      display: block;
      font-size: 0.96rem;
      letter-spacing: 0.02em;
    }

    .mode-card small {
      display: block;
      margin-top: 5px;
      color: var(--muted);
      font-size: 0.8rem;
      line-height: 1.35;
    }

    .mode-card.active {
      border-color: rgba(255, 211, 106, 0.88);
      box-shadow: 0 0 0 1px rgba(255, 211, 106, 0.45) inset;
      background: linear-gradient(145deg, rgba(53, 43, 19, 0.88), rgba(27, 23, 44, 0.9));
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #2de4ff, #7c8cff 52%, #f867de);
      color: #050914;
      border: none;
      font-weight: 800;
      letter-spacing: 0.03em;
    }

    .btn-light {
      border-color: rgba(130, 165, 255, 0.35);
      background: rgba(16, 29, 57, 0.84);
      color: #dfeaff;
    }

    .btn-danger {
      border-color: rgba(255, 102, 122, 0.58);
      background: rgba(84, 20, 34, 0.58);
      color: #ffb9c3;
    }

    .hint {
      font-size: 0.82rem;
      color: var(--muted);
      line-height: 1.45;
    }

    .arena {
      padding: 14px;
      min-height: 560px;
    }

    .arena-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .arena-title {
      margin: 0;
      font-size: 1.08rem;
      letter-spacing: 0.03em;
    }

    .arena-sub {
      margin: 3px 0 0;
      color: var(--muted);
      font-size: 0.86rem;
    }

    .bar {
      height: 10px;
      border-radius: 999px;
      background: rgba(117, 146, 209, 0.28);
      overflow: hidden;
      border: 1px solid rgba(117, 146, 209, 0.38);
    }

    .bar > i {
      display: block;
      height: 100%;
      width: 0;
      transition: width 0.18s linear;
      background: linear-gradient(90deg, #2de4ff, #87a7ff, #f867de);
    }

    .question-card {
      margin-top: 10px;
      border: 1px solid rgba(131, 164, 255, 0.34);
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(13, 27, 57, 0.9), rgba(17, 35, 76, 0.72));
      padding: 14px;
      position: relative;
      overflow: hidden;
    }

    .question-card::after {
      content: "";
      position: absolute;
      top: -48%;
      left: -12%;
      width: 60%;
      height: 200%;
      transform: rotate(20deg);
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.08), transparent);
      pointer-events: none;
      animation: sweep 4s linear infinite;
    }

    @keyframes sweep {
      to { transform: translateX(240%) rotate(20deg); }
    }

    .question-type {
      font-size: 0.76rem;
      color: #9ac2ff;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .question-main {
      margin: 0;
      font-size: clamp(1.35rem, 2.5vw, 2rem);
      line-height: 1.3;
      text-shadow: 0 4px 14px rgba(6, 14, 35, 0.6);
      position: relative;
      z-index: 1;
    }

    .question-sub {
      margin: 7px 0 0;
      color: var(--muted);
      font-size: 0.9rem;
      position: relative;
      z-index: 1;
    }

    .option-grid {
      margin-top: 12px;
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr 1fr;
    }

    .option {
      border-radius: 12px;
      border: 1px solid rgba(140, 173, 255, 0.38);
      background: rgba(13, 26, 53, 0.9);
      color: var(--text);
      padding: 10px;
      text-align: left;
      cursor: pointer;
      transition: transform 0.12s ease, border-color 0.12s ease;
    }

    .option:hover {
      transform: translateY(-1px);
      border-color: rgba(65, 232, 255, 0.72);
    }

    .option.ok {
      border-color: rgba(59, 230, 138, 0.84);
      background: rgba(19, 70, 51, 0.72);
    }

    .option.bad {
      border-color: rgba(255, 102, 122, 0.84);
      background: rgba(79, 24, 40, 0.72);
    }

    .battle-row {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .battle-card {
      border: 1px solid rgba(130, 164, 255, 0.33);
      border-radius: 12px;
      background: rgba(12, 24, 50, 0.8);
      padding: 10px;
    }

    .battle-card h4 {
      margin: 0 0 8px;
      font-size: 0.88rem;
      color: var(--muted);
      font-weight: 600;
    }

    .hp {
      margin-top: 6px;
      font-size: 1.04rem;
      letter-spacing: 0.06em;
      color: #ffc6d6;
    }

    .input {
      width: 100%;
      border: 1px solid rgba(132, 165, 255, 0.5);
      border-radius: 12px;
      padding: 11px 12px;
      background: rgba(9, 18, 40, 0.88);
      color: var(--text);
      font: inherit;
      font-size: 1rem;
      margin-top: 10px;
    }

    .input:focus {
      outline: 2px solid rgba(65, 232, 255, 0.52);
      outline-offset: 1px;
    }

    .feedback {
      margin-top: 10px;
      min-height: 24px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .feedback.good { color: var(--good); }
    .feedback.bad { color: var(--bad); }

    .memory-grid {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .memory-card {
      height: 84px;
      border-radius: 12px;
      border: 1px solid rgba(127, 160, 255, 0.42);
      background: linear-gradient(145deg, rgba(16, 30, 58, 0.94), rgba(10, 20, 41, 0.94));
      color: transparent;
      display: grid;
      place-items: center;
      padding: 8px;
      text-align: center;
      cursor: pointer;
      font-size: 0.92rem;
      transition: transform 0.12s ease, border-color 0.12s ease, color 0.12s ease;
      user-select: none;
    }

    .memory-card.revealed {
      color: var(--text);
      border-color: rgba(65, 232, 255, 0.72);
      background: linear-gradient(145deg, rgba(23, 42, 81, 0.94), rgba(16, 31, 62, 0.94));
      transform: translateY(-1px);
    }

    .memory-card.matched {
      color: #07111f;
      border-color: rgba(59, 230, 138, 0.95);
      background: linear-gradient(145deg, rgba(59, 230, 138, 0.9), rgba(117, 238, 187, 0.84));
      font-weight: 700;
      cursor: default;
    }

    .log {
      margin-top: 12px;
      border: 1px solid rgba(129, 162, 246, 0.34);
      border-radius: 12px;
      background: rgba(9, 17, 38, 0.76);
      padding: 10px;
      min-height: 88px;
      max-height: 164px;
      overflow: auto;
      font-size: 0.83rem;
      line-height: 1.46;
      color: var(--muted);
    }

    .log b { color: #dcedff; }

    .word-book {
      padding: 12px;
    }

    .word-book-grid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .word-tag {
      border-radius: 10px;
      border: 1px solid rgba(130, 162, 246, 0.3);
      background: rgba(11, 20, 44, 0.76);
      padding: 7px 8px;
      font-size: 0.8rem;
    }

    .word-tag small {
      display: block;
      margin-top: 2px;
      color: var(--muted);
      font-size: 0.72rem;
    }

    .spark {
      position: fixed;
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: #fff;
      pointer-events: none;
      z-index: 20;
      box-shadow: 0 0 14px #fff;
      animation: spark 720ms ease-out forwards;
    }

    @keyframes spark {
      from {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      to {
        opacity: 0;
        transform: translateY(-42px) scale(0.3);
      }
    }

    @media (max-width: 1050px) {
      .main-grid {
        grid-template-columns: 1fr;
      }

      .dashboard {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 720px) {
      body { padding: 10px; }
      .option-grid,
      .battle-row {
        grid-template-columns: 1fr;
      }
      .memory-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      .word-book-grid {
        grid-template-columns: 1fr 1fr;
      }
      .dashboard {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .unit-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <section class="panel hero">
      <div class="hero-main">
        <h1>英语词汇星域 · Grade 8 Memory Arcade</h1>
        <p>上海初二词汇强化系统：娱乐闯关 + 记忆复习 + 即时反馈。覆盖 Unit 1-6 核心词与短语。</p>
      </div>
      <div class="hero-side">
        <div class="pill-row">
          <span class="pill">炫光闯关</span>
          <span class="pill">错词回放</span>
          <span class="pill">BOSS拼写战</span>
        </div>
      </div>
    </section>

    <section class="panel dashboard" id="dashboard"></section>

    <div class="main-grid">
      <section class="panel control">
        <div>
          <h3 class="panel-title">选择词汇单元</h3>
          <div class="unit-grid" id="unitGrid"></div>
        </div>

        <div>
          <h3 class="panel-title">玩法模式</h3>
          <div class="mode-grid" id="modeGrid"></div>
        </div>

        <div class="btn-row">
          <button class="btn btn-primary" id="startBtn">开始本轮</button>
          <button class="btn btn-light" id="nextBtn">下一题</button>
          <button class="btn btn-danger" id="resetBtn">重置进度</button>
        </div>

        <div class="hint" id="modeHint"></div>
      </section>

      <section class="panel arena">
        <div class="arena-head">
          <div>
            <h3 class="arena-title" id="arenaTitle">准备进入英语词汇星域</h3>
            <p class="arena-sub" id="arenaSub">先选 Unit 和模式，再开始本轮训练。</p>
          </div>
          <div style="min-width: 220px; width: min(280px, 46vw);">
            <div class="bar"><i id="progressBar"></i></div>
          </div>
        </div>
        <div id="arenaBody"></div>
        <div class="feedback" id="feedback"></div>
        <div class="log" id="log"></div>
      </section>
    </div>

    <section class="panel word-book">
      <h3 class="panel-title">易错词回放（优先复习）</h3>
      <div class="word-book-grid" id="weakWords"></div>
    </section>
  </div>

  <script>
    const MODES = [
      {
        id: "rush",
        name: "闪电四选一",
        desc: "限时四选一，连击越高分越高。快速建立词义反射。",
        hint: "每题 12 秒，答错会打断连击。适合热身与提速。"
      },
      {
        id: "memory",
        name: "记忆翻牌局",
        desc: "英汉配对翻牌，强制回忆并纠正模糊记忆。",
        hint: "一次翻两张，配对成功会提升记忆盒等级。"
      },
      {
        id: "boss",
        name: "BOSS 拼写战",
        desc: "根据中文释义拼写英文，击穿 BOSS 血条。",
        hint: "偏重精确拼写。错误会掉心，连续命中有暴击伤害。"
      }
    ];

    const WORDS = [
      { unit: 1, en: "self-expression", zh: "自我表达" },
      { unit: 1, en: "creativity", zh: "创造力" },
      { unit: 1, en: "scissors", zh: "剪刀" },
      { unit: 1, en: "drama", zh: "戏剧" },
      { unit: 1, en: "acting", zh: "表演" },
      { unit: 1, en: "normal", zh: "正常的；典型的" },
      { unit: 1, en: "prefer ... to ...", zh: "更喜欢...而不是..." },
      { unit: 1, en: "pottery", zh: "陶器；陶艺" },
      { unit: 1, en: "rather than", zh: "而不是" },
      { unit: 1, en: "position", zh: "位置" },
      { unit: 1, en: "instrument", zh: "器具；仪器" },
      { unit: 1, en: "sculpture", zh: "雕塑" },
      { unit: 1, en: "sculptor", zh: "雕塑家" },
      { unit: 1, en: "landscape", zh: "风景" },
      { unit: 1, en: "master", zh: "大师；能手" },
      { unit: 1, en: "dynasty", zh: "朝代" },
      { unit: 1, en: "paint", zh: "绘画；颜料" },
      { unit: 1, en: "harmony", zh: "和谐" },
      { unit: 1, en: "path", zh: "小道" },
      { unit: 1, en: "ahead", zh: "在前方" },
      { unit: 1, en: "whoever", zh: "无论谁" },
      { unit: 1, en: "come across", zh: "偶然遇见；发现" },
      { unit: 1, en: "scare", zh: "使惊吓" },
      { unit: 1, en: "scared", zh: "害怕的" },
      { unit: 1, en: "vivid", zh: "生动的" },
      { unit: 1, en: "east", zh: "东；东方" },
      { unit: 1, en: "west", zh: "西；西方" },
      { unit: 1, en: "peaceful", zh: "安静的；宁静的" },

      { unit: 2, en: "discovery", zh: "发现" },
      { unit: 2, en: "ancient", zh: "古代的" },
      { unit: 2, en: "BCE", zh: "公元前" },
      { unit: 2, en: "CE", zh: "公元" },
      { unit: 2, en: "exploration", zh: "探索；勘查" },
      { unit: 2, en: "wheel", zh: "轮子" },
      { unit: 2, en: "economy", zh: "经济" },
      { unit: 2, en: "material", zh: "材料；原料" },
      { unit: 2, en: "fishnet", zh: "渔网" },
      { unit: 2, en: "war", zh: "战争" },
      { unit: 2, en: "excite", zh: "使兴奋" },
      { unit: 2, en: "illness", zh: "疾病" },
      { unit: 2, en: "socialism", zh: "社会主义" },
      { unit: 2, en: "habit", zh: "习惯" },
      { unit: 2, en: "hardly", zh: "几乎不" },
      { unit: 2, en: "totally", zh: "完全地" },
      { unit: 2, en: "telephone", zh: "电话" },
      { unit: 2, en: "tube", zh: "管子" },
      { unit: 2, en: "bone", zh: "骨头" },
      { unit: 2, en: "X-ray", zh: "X 光" },
      { unit: 2, en: "award", zh: "奖励" },
      { unit: 2, en: "sir", zh: "先生；爵士" },
      { unit: 2, en: "by accident", zh: "偶然；意外地" },
      { unit: 2, en: "mould", zh: "霉菌" },
      { unit: 2, en: "to one's surprise", zh: "令某人惊讶的是" },
      { unit: 2, en: "bacteria", zh: "细菌" },
      { unit: 2, en: "turn ... into", zh: "使...变成" },
      { unit: 2, en: "life-saving", zh: "救命的" },
      { unit: 2, en: "course", zh: "课程；进程" },
      { unit: 2, en: "treat", zh: "医治" },
      { unit: 2, en: "serious", zh: "严重的" },
      { unit: 2, en: "malaria", zh: "疟疾" },
      { unit: 2, en: "medical", zh: "医学的；医疗的" },
      { unit: 2, en: "light up", zh: "点亮；使变亮" },
      { unit: 2, en: "volunteer", zh: "志愿做；志愿者" },
      { unit: 2, en: "herself", zh: "她自己" },
      { unit: 2, en: "keep in touch", zh: "保持联系" },
      { unit: 2, en: "spare", zh: "空闲的" },
      { unit: 2, en: "independent", zh: "独立的" },
      { unit: 2, en: "responsible", zh: "负责的" },
      { unit: 2, en: "mess", zh: "使不整洁；混乱" },
      { unit: 2, en: "mess up", zh: "弄糟" },
      { unit: 2, en: "responsibility", zh: "责任" },
      { unit: 2, en: "value", zh: "价值；用途" },
      { unit: 2, en: "account", zh: "账户" },
      { unit: 2, en: "bank", zh: "银行" },
      { unit: 2, en: "economics", zh: "经济学" },
      { unit: 2, en: "whatever", zh: "任何事物；无论什么" },
      { unit: 2, en: "economist", zh: "经济学家" },
      { unit: 2, en: "society", zh: "社会" },
      { unit: 2, en: "trade", zh: "贸易；交易" },
      { unit: 2, en: "exchange", zh: "交换" },
      { unit: 2, en: "goods", zh: "商品；货品" },
      { unit: 2, en: "sample", zh: "样品" },
      { unit: 2, en: "saying", zh: "谚语；格言" },
      { unit: 2, en: "cost", zh: "成本；花费" },
      { unit: 2, en: "even if", zh: "即使" },
      { unit: 2, en: "might", zh: "可能；可以" },
      { unit: 2, en: "complete", zh: "完整的；完成" },
      { unit: 2, en: "completely", zh: "完全地" },
      { unit: 2, en: "valuable", zh: "有价值的；宝贵的" },
      { unit: 2, en: "pie", zh: "馅饼" },
      { unit: 2, en: "pie chart", zh: "饼形图" },
      { unit: 2, en: "percentage", zh: "百分率" },

      { unit: 3, en: "mall", zh: "购物商场" },
      { unit: 3, en: "sale", zh: "出售；销售" },
      { unit: 3, en: "payment", zh: "支付；付款" },
      { unit: 3, en: "cash", zh: "现金" },
      { unit: 3, en: "honey", zh: "亲爱的；蜂蜜" },
      { unit: 3, en: "assistant", zh: "店员；助手" },
      { unit: 3, en: "deal", zh: "交易；协议" },
      { unit: 3, en: "bill", zh: "账单" },
      { unit: 3, en: "donate", zh: "捐赠" },
      { unit: 3, en: "pound", zh: "英镑；磅" },
      { unit: 3, en: "cheap", zh: "便宜的" },
      { unit: 3, en: "chocolate", zh: "巧克力" },
      { unit: 3, en: "pocket", zh: "衣袋；口袋" },
      { unit: 3, en: "pocket money", zh: "零花钱" },
      { unit: 3, en: "expectation", zh: "期待；预期" },
      { unit: 3, en: "budget", zh: "预算" },
      { unit: 3, en: "financial", zh: "财政的；金融的" },
      { unit: 3, en: "in short", zh: "总之；简言之" },
      { unit: 3, en: "account for", zh: "占（数量上比例）" },

      { unit: 4, en: "fashion", zh: "时尚" },
      { unit: 4, en: "trainers", zh: "运动鞋" },
      { unit: 4, en: "decoration", zh: "装饰品" },
      { unit: 4, en: "afford", zh: "买得起；承担得起" },
      { unit: 4, en: "changeable", zh: "易变的" },
      { unit: 4, en: "fashionable", zh: "流行的" },
      { unit: 4, en: "flowery", zh: "用花装饰的" },
      { unit: 4, en: "outfit", zh: "全套服装" },
      { unit: 4, en: "narrow", zh: "狭窄的" },
      { unit: 4, en: "baggy", zh: "宽松的" },
      { unit: 4, en: "advertising", zh: "广告业；广告活动" },
      { unit: 4, en: "a great deal of", zh: "很多；大量" },
      { unit: 4, en: "advertisement", zh: "广告" },
      { unit: 4, en: "image", zh: "形象；印象" },
      { unit: 4, en: "influencer", zh: "有影响力的人" },
      { unit: 4, en: "pioneer", zh: "先锋；带头人" },
      { unit: 4, en: "jewellery", zh: "珠宝；首饰" },
      { unit: 4, en: "attract", zh: "吸引" },
      { unit: 4, en: "relaxed", zh: "放松的；自在的" },
      { unit: 4, en: "mention", zh: "提到" },
      { unit: 4, en: "grade", zh: "分数；等级" },
      { unit: 4, en: "interest", zh: "兴趣" },

      { unit: 5, en: "disaster", zh: "灾难" },
      { unit: 5, en: "flood", zh: "洪水" },
      { unit: 5, en: "earthquake", zh: "地震" },
      { unit: 5, en: "terrible", zh: "可怕的" },
      { unit: 5, en: "force", zh: "力量；迫使" },
      { unit: 5, en: "injury", zh: "伤害；损伤" },
      { unit: 5, en: "death", zh: "死亡" },
      { unit: 5, en: "destroy", zh: "摧毁；破坏" },
      { unit: 5, en: "injure", zh: "使受伤" },
      { unit: 5, en: "effect", zh: "影响；作用" },
      { unit: 5, en: "dollar", zh: "元（美元等）" },
      { unit: 5, en: "Rd.", zh: "路（road）" },
      { unit: 5, en: "Dr.", zh: "博士；医生（doctor）" },
      { unit: 5, en: "exam", zh: "考试" },
      { unit: 5, en: "typhoon", zh: "台风" },
      { unit: 5, en: "battery", zh: "电池" },
      { unit: 5, en: "case", zh: "具体情况；案例" },
      { unit: 5, en: "in case", zh: "以防；以防万一" },
      { unit: 5, en: "go off", zh: "（电）中断；响起" },
      { unit: 5, en: "pick up", zh: "增强；改善；收拾" },
      { unit: 5, en: "lock", zh: "锁住；锁" },
      { unit: 5, en: "anyway", zh: "不过；总之" },
      { unit: 5, en: "anybody", zh: "任何人" },
      { unit: 5, en: "low-lying", zh: "低洼的" },
      { unit: 5, en: "cancel", zh: "取消" },
      { unit: 5, en: "necessary", zh: "必要的" },
      { unit: 5, en: "electronic", zh: "电子的" },
      { unit: 5, en: "be careful of", zh: "小心；当心" },
      { unit: 5, en: "survive", zh: "幸存" },
      { unit: 5, en: "similar", zh: "相像的" },
      { unit: 5, en: "foam", zh: "泡沫" },
      { unit: 5, en: "rapid", zh: "迅速的" },
      { unit: 5, en: "rapidly", zh: "迅速地" },

      { unit: 6, en: "towards", zh: "朝；向" },
      { unit: 6, en: "nothing", zh: "没什么；无关紧要的事" },
      { unit: 6, en: "whether", zh: "是否" },
      { unit: 6, en: "get away", zh: "离开；逃离" },
      { unit: 6, en: "hotel", zh: "旅馆" },
      { unit: 6, en: "guard", zh: "警卫；看守" },
      { unit: 6, en: "urge", zh: "敦促；力劝" },
      { unit: 6, en: "super", zh: "超级的" },
      { unit: 6, en: "seaside", zh: "海边" },
      { unit: 6, en: "last", zh: "持续；最近的" },
      { unit: 6, en: "thunder", zh: "雷；雷声" },
      { unit: 6, en: "coast", zh: "海岸" },
      { unit: 6, en: "rise", zh: "上升；升高" },
      { unit: 6, en: "injured", zh: "受伤的" },
      { unit: 6, en: "rescue", zh: "营救；营救行动" },
      { unit: 6, en: "tent", zh: "帐篷" },
      { unit: 6, en: "confused", zh: "困惑的" },
      { unit: 6, en: "tool", zh: "工具" },
      { unit: 6, en: "knife", zh: "刀" },
      { unit: 6, en: "fork", zh: "叉子" },
      { unit: 6, en: "packet", zh: "密封小袋" },
      { unit: 6, en: "seed", zh: "种子" },
      { unit: 6, en: "dead", zh: "死的；枯萎的" },
      { unit: 6, en: "cheerleader", zh: "拉拉队队员" },
      { unit: 6, en: "yourself", zh: "你自己" },
      { unit: 6, en: "hers", zh: "她的（名词性）" },
      { unit: 6, en: "whenever", zh: "无论何时" },
      { unit: 6, en: "be mean to sb", zh: "对某人刻薄" },
      { unit: 6, en: "stare", zh: "盯着看" },
      { unit: 6, en: "hang", zh: "悬挂；吊" },
      { unit: 6, en: "hang out", zh: "常去某处" },
      { unit: 6, en: "dig", zh: "挖；掘" },
      { unit: 6, en: "neither", zh: "两者都不" },
      { unit: 6, en: "as if", zh: "好像；仿佛" },
      { unit: 6, en: "lie", zh: "躺；平躺" },
      { unit: 6, en: "rug", zh: "垫子；小地毯" },
      { unit: 6, en: "ache", zh: "疼痛" },
      { unit: 6, en: "joke", zh: "玩笑" },
      { unit: 6, en: "terribly", zh: "非常糟地；严重地" },
      { unit: 6, en: "finish", zh: "完成；结束" },
      { unit: 6, en: "over the moon", zh: "欣喜若狂" },
      { unit: 6, en: "especially", zh: "尤其；特别" },
      { unit: 6, en: "novel", zh: "小说" },
      { unit: 6, en: "magical", zh: "魔法的；神奇的" },
      { unit: 6, en: "cheerful", zh: "开朗的；乐观的" },
      { unit: 6, en: "bad-tempered", zh: "易怒的" },
      { unit: 6, en: "caring", zh: "关心他人的；体贴的" },
      { unit: 6, en: "doubtful", zh: "怀疑的；不确定的" },
      { unit: 6, en: "firm", zh: "坚定的；坚决的" }
    ].map((w, idx) => ({ ...w, id: `u${w.unit}-${idx}-${w.en.toLowerCase()}` }));

    const STORAGE_KEY = "eng_vocab_arcade_v1";

    const state = {
      unit: 1,
      mode: "rush",
      running: false,
      roundSize: 12,
      index: 0,
      combo: 0,
      qList: [],
      timer: null,
      timeLeft: 12,
      memory: null,
      boss: null,
      current: null,
      locked: false,
      progress: loadProgress()
    };

    const modeHintEl = document.getElementById("modeHint");
    const unitGridEl = document.getElementById("unitGrid");
    const modeGridEl = document.getElementById("modeGrid");
    const startBtn = document.getElementById("startBtn");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");
    const dashboardEl = document.getElementById("dashboard");
    const arenaTitleEl = document.getElementById("arenaTitle");
    const arenaSubEl = document.getElementById("arenaSub");
    const arenaBodyEl = document.getElementById("arenaBody");
    const feedbackEl = document.getElementById("feedback");
    const logEl = document.getElementById("log");
    const progressBarEl = document.getElementById("progressBar");
    const weakWordsEl = document.getElementById("weakWords");

    function loadProgress() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && parsed.wordStats) return parsed;
        }
      } catch (err) {
        console.warn("load progress failed", err);
      }
      return {
        xp: 0,
        coins: 0,
        bestCombo: 0,
        totalCorrect: 0,
        totalWrong: 0,
        sessions: 0,
        wordStats: {}
      };
    }

    function saveProgress() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state.progress));
    }

    function levelOf(xp) {
      return Math.floor(xp / 240) + 1;
    }

    function ensureWordStat(wordId) {
      const bag = state.progress.wordStats;
      if (!bag[wordId]) {
        bag[wordId] = {
          right: 0,
          wrong: 0,
          streak: 0,
          box: 1,
          dueAt: 0,
          seen: 0
        };
      }
      return bag[wordId];
    }

    function dueWeight(word) {
      const st = ensureWordStat(word.id);
      const now = Date.now();
      const overdue = Math.max(0, now - st.dueAt);
      const weakBias = st.wrong * 2 - st.right * 0.4;
      return overdue / 60000 + weakBias + (st.box <= 2 ? 6 : 0) + 1;
    }

    function pickWords(pool, n) {
      const copy = pool.slice();
      const out = [];
      while (copy.length && out.length < n) {
        const total = copy.reduce((sum, w) => sum + Math.max(0.2, dueWeight(w)), 0);
        let target = Math.random() * total;
        let idx = 0;
        for (; idx < copy.length; idx += 1) {
          target -= Math.max(0.2, dueWeight(copy[idx]));
          if (target <= 0) break;
        }
        out.push(copy.splice(Math.min(idx, copy.length - 1), 1)[0]);
      }
      return out;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function normalizeText(text) {
      return text
        .toLowerCase()
        .replace(/[’']/g, "'")
        .replace(/\s+/g, " ")
        .trim();
    }

    function nextDueByBox(box) {
      const mins = [0, 3, 12, 60, 360, 1440];
      return Date.now() + mins[Math.max(1, Math.min(5, box))] * 60000;
    }

    function recordResult(word, correct) {
      const st = ensureWordStat(word.id);
      st.seen += 1;
      if (correct) {
        st.right += 1;
        st.streak += 1;
        st.box = Math.min(5, st.box + 1);
        st.dueAt = nextDueByBox(st.box);
        state.progress.totalCorrect += 1;
        state.combo += 1;
        state.progress.bestCombo = Math.max(state.progress.bestCombo, state.combo);
        const gain = 10 + Math.min(12, state.combo * 2) + (st.box >= 4 ? 3 : 0);
        state.progress.xp += gain;
        state.progress.coins += Math.max(1, Math.floor(gain / 4));
        sparkle(8);
        feedback(`+${gain} XP · 连击 x${state.combo}`, "good");
      } else {
        st.wrong += 1;
        st.streak = 0;
        st.box = Math.max(1, st.box - 1);
        st.dueAt = Date.now() + 90 * 1000;
        state.progress.totalWrong += 1;
        state.combo = 0;
        state.progress.xp += 2;
        feedback(`记忆回退：${word.en}（${word.zh}）`, "bad");
      }
      saveProgress();
      renderDashboard();
      renderWeakWords();
    }

    function feedback(msg, type = "") {
      feedbackEl.textContent = msg;
      feedbackEl.className = `feedback ${type}`;
    }

    function log(msg) {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, "0");
      const mm = String(now.getMinutes()).padStart(2, "0");
      const line = document.createElement("div");
      line.innerHTML = `<b>[${hh}:${mm}]</b> ${msg}`;
      logEl.prepend(line);
      while (logEl.children.length > 40) {
        logEl.removeChild(logEl.lastChild);
      }
    }

    function sparkle(count) {
      for (let i = 0; i < count; i += 1) {
        const node = document.createElement("i");
        node.className = "spark";
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight;
        node.style.left = `${x}px`;
        node.style.top = `${y}px`;
        node.style.background = i % 3 === 0 ? "#41e8ff" : i % 3 === 1 ? "#fff" : "#ff8de7";
        document.body.appendChild(node);
        setTimeout(() => node.remove(), 720);
      }
    }

    function unitPool() {
      return WORDS.filter((w) => w.unit === state.unit);
    }

    function renderDashboard() {
      const { xp, coins, bestCombo, totalCorrect, totalWrong } = state.progress;
      const lv = levelOf(xp);
      const pool = unitPool();
      const dueCount = pool.filter((w) => ensureWordStat(w.id).dueAt <= Date.now()).length;
      const acc = totalCorrect + totalWrong === 0 ? 0 : Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100);
      const mastered = pool.filter((w) => ensureWordStat(w.id).box >= 4).length;

      const metrics = [
        ["等级 Level", `Lv.${lv}`],
        ["经验 XP", String(xp)],
        ["金币 Coin", String(coins)],
        ["最高连击", `x${bestCombo}`],
        ["准确率", `${acc}%`],
        ["待复习词", `${dueCount}/${pool.length}`],
        ["本单元掌握", `${mastered}/${pool.length}`],
        ["当前连击", `x${state.combo}`]
      ];

      dashboardEl.innerHTML = metrics
        .map(([k, v]) => `<div class="metric"><span>${k}</span><strong>${v}</strong></div>`)
        .join("");
    }

    function renderWeakWords() {
      const pool = unitPool();
      const list = pool
        .map((w) => {
          const st = ensureWordStat(w.id);
          const score = st.wrong * 3 - st.right + (st.box <= 2 ? 3 : 0);
          return { w, st, score };
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, 12);

      weakWordsEl.innerHTML = list
        .map(({ w, st }) => {
          const rate = st.right + st.wrong === 0 ? "--" : `${Math.round((st.right / (st.right + st.wrong)) * 100)}%`;
          return `
            <div class="word-tag">
              ${w.en}
              <small>${w.zh} · 盒${st.box} · 正确率 ${rate}</small>
            </div>`;
        })
        .join("");
    }

    function renderUnitSelector() {
      const units = [1, 2, 3, 4, 5, 6];
      unitGridEl.innerHTML = units
        .map((u) => `<button class="chip ${u === state.unit ? "active" : ""}" data-unit="${u}">Unit ${u}</button>`)
        .join("");

      unitGridEl.querySelectorAll(".chip").forEach((btn) => {
        btn.addEventListener("click", () => {
          state.unit = Number(btn.dataset.unit);
          state.combo = 0;
          renderUnitSelector();
          renderDashboard();
          renderWeakWords();
          setArenaIntro();
        });
      });
    }

    function renderModeSelector() {
      modeGridEl.innerHTML = MODES
        .map((m) => `
          <button class="mode-card ${m.id === state.mode ? "active" : ""}" data-mode="${m.id}">
            <strong>${m.name}</strong>
            <small>${m.desc}</small>
          </button>`)
        .join("");

      modeGridEl.querySelectorAll(".mode-card").forEach((btn) => {
        btn.addEventListener("click", () => {
          state.mode = btn.dataset.mode;
          renderModeSelector();
          renderModeHint();
          setArenaIntro();
        });
      });
    }

    function renderModeHint() {
      const m = MODES.find((x) => x.id === state.mode);
      modeHintEl.textContent = `${m.name}：${m.hint}`;
    }

    function setArenaIntro() {
      clearTimer();
      state.running = false;
      progressBar(0);
      const mode = MODES.find((m) => m.id === state.mode);
      arenaTitleEl.textContent = `Unit ${state.unit} · ${mode.name}`;
      arenaSubEl.textContent = mode.desc;
      arenaBodyEl.innerHTML = `
        <div class="question-card">
          <div class="question-type">READY</div>
          <p class="question-main">点击“开始本轮”进入挑战</p>
          <p class="question-sub">当前词库：${unitPool().length} 个。系统会优先抽取你的易错词。</p>
        </div>`;
      feedback("", "");
    }

    function progressBar(v) {
      progressBarEl.style.width = `${Math.max(0, Math.min(100, v))}%`;
    }

    function clearTimer() {
      if (state.timer) {
        clearInterval(state.timer);
        state.timer = null;
      }
    }

    function startMode() {
      if (state.mode === "rush") startRush();
      else if (state.mode === "memory") startMemory();
      else startBoss();
    }

    function startRush() {
      clearTimer();
      state.running = true;
      state.locked = false;
      state.index = 0;
      state.timeLeft = 12;
      const pool = unitPool();
      const qSize = Math.min(12, pool.length);
      state.qList = pickWords(pool, qSize);
      state.progress.sessions += 1;
      saveProgress();
      log(`进入 Unit ${state.unit} 闪电四选一，共 ${qSize} 题`);
      renderRushQuestion();
    }

    function makeRushQuestion(word) {
      const reverse = Math.random() > 0.5;
      const pool = unitPool().filter((w) => w.id !== word.id);
      const wrongs = shuffle(pool.slice()).slice(0, 3);
      const options = shuffle([word, ...wrongs]);

      return {
        word,
        reverse,
        ask: reverse ? word.zh : word.en,
        answer: reverse ? word.en : word.zh,
        options: options.map((w) => (reverse ? w.en : w.zh))
      };
    }

    function startRushTimer() {
      clearTimer();
      state.timeLeft = 12;
      progressBar(100);
      state.timer = setInterval(() => {
        state.timeLeft -= 0.1;
        progressBar((state.timeLeft / 12) * 100);
        if (state.timeLeft <= 0) {
          clearTimer();
          state.locked = true;
          if (state.current) {
            recordResult(state.current.word, false);
            log(`超时：${state.current.word.en}`);
          }
          setTimeout(nextQuestion, 650);
        }
      }, 100);
    }

    function renderRushQuestion() {
      if (state.index >= state.qList.length) {
        return endRush();
      }

      const q = makeRushQuestion(state.qList[state.index]);
      state.current = q;
      state.locked = false;
      const type = q.reverse ? "中文 -> 选英文" : "英文 -> 选中文";
      const progress = (state.index / state.qList.length) * 100;
      progressBar(progress);

      arenaTitleEl.textContent = `Unit ${state.unit} · 闪电四选一`;
      arenaSubEl.textContent = `第 ${state.index + 1} / ${state.qList.length} 题`;

      arenaBodyEl.innerHTML = `
        <div class="question-card">
          <div class="question-type">${type}</div>
          <p class="question-main">${q.ask}</p>
          <p class="question-sub">12 秒内完成选择，保持连击可获得额外 XP。</p>
        </div>
        <div class="option-grid" id="optionGrid">
          ${q.options.map((opt) => `<button class="option" data-opt="${escapeHtml(opt)}">${opt}</button>`).join("")}
        </div>
      `;

      const optionGrid = document.getElementById("optionGrid");
      optionGrid.querySelectorAll(".option").forEach((btn) => {
        btn.addEventListener("click", () => handleRushAnswer(btn, q));
      });

      startRushTimer();
    }

    function handleRushAnswer(btn, q) {
      if (state.locked) return;
      state.locked = true;
      clearTimer();
      const value = btn.textContent;
      const optionBtns = arenaBodyEl.querySelectorAll(".option");
      optionBtns.forEach((el) => {
        if (el.textContent === q.answer) el.classList.add("ok");
      });

      if (value === q.answer) {
        btn.classList.add("ok");
        recordResult(q.word, true);
        log(`命中：${q.word.en}`);
      } else {
        btn.classList.add("bad");
        recordResult(q.word, false);
        log(`失误：${q.word.en} -> ${q.word.zh}`);
      }

      setTimeout(nextQuestion, 640);
    }

    function nextQuestion() {
      if (state.mode === "rush") {
        state.index += 1;
        renderRushQuestion();
      }
    }

    function endRush() {
      clearTimer();
      state.running = false;
      progressBar(100);
      arenaTitleEl.textContent = `Unit ${state.unit} · 本轮完成`;
      arenaSubEl.textContent = "闪电模式已结束";
      arenaBodyEl.innerHTML = `
        <div class="question-card">
          <div class="question-type">ROUND CLEAR</div>
          <p class="question-main">做得不错，继续下一轮？</p>
          <p class="question-sub">系统已将错词自动加入优先复习队列。</p>
        </div>
      `;
      feedback("本轮结束。可切换模式做深度记忆。", "good");
      log("闪电四选一完成");
    }

    function startMemory() {
      clearTimer();
      state.running = true;
      const pool = pickWords(unitPool(), Math.min(8, unitPool().length));
      const pick = pool.slice(0, Math.min(6, pool.length));
      const cards = [];
      pick.forEach((w) => {
        cards.push({ uid: `${w.id}-en`, wordId: w.id, text: w.en, type: "en", matched: false, revealed: false, word: w });
        cards.push({ uid: `${w.id}-zh`, wordId: w.id, text: w.zh, type: "zh", matched: false, revealed: false, word: w });
      });
      state.memory = {
        cards: shuffle(cards),
        revealed: [],
        pairs: 0,
        moves: 0,
        total: pick.length,
        lock: false
      };
      arenaTitleEl.textContent = `Unit ${state.unit} · 记忆翻牌局`;
      arenaSubEl.textContent = `共 ${pick.length} 对英汉词条，完成配对即可通关`;
      renderMemory();
      feedback("", "");
      log(`进入记忆翻牌，目标 ${pick.length} 对`);
    }

    function renderMemory() {
      const m = state.memory;
      progressBar((m.pairs / m.total) * 100);
      arenaBodyEl.innerHTML = `
        <div class="question-card">
          <div class="question-type">PAIR MEMORY</div>
          <p class="question-main">已配对 ${m.pairs} / ${m.total}</p>
          <p class="question-sub">步数 ${m.moves}。先翻英文再找中文（或反过来）。</p>
        </div>
        <div class="memory-grid" id="memoryGrid">
          ${m.cards.map((c, idx) => {
            const cls = ["memory-card"];
            if (c.revealed) cls.push("revealed");
            if (c.matched) cls.push("matched");
            const txt = c.revealed || c.matched ? c.text : "✦";
            return `<button class="${cls.join(" ")}" data-idx="${idx}">${txt}</button>`;
          }).join("")}
        </div>
      `;

      const grid = document.getElementById("memoryGrid");
      grid.querySelectorAll(".memory-card").forEach((btn) => {
        btn.addEventListener("click", () => flipMemory(Number(btn.dataset.idx)));
      });
    }

    function flipMemory(idx) {
      const m = state.memory;
      if (!m || m.lock) return;
      const card = m.cards[idx];
      if (card.matched || card.revealed) return;
      card.revealed = true;
      m.revealed.push(idx);
      renderMemory();

      if (m.revealed.length < 2) return;

      m.moves += 1;
      const [aIdx, bIdx] = m.revealed;
      const a = m.cards[aIdx];
      const b = m.cards[bIdx];

      if (a.wordId === b.wordId && a.type !== b.type) {
        a.matched = true;
        b.matched = true;
        m.revealed = [];
        m.pairs += 1;
        recordResult(a.word, true);
        feedback(`配对成功：${a.word.en}`, "good");
        log(`翻牌命中：${a.word.en}`);
        if (m.pairs >= m.total) {
          endMemory();
        } else {
          renderMemory();
        }
      } else {
        m.lock = true;
        recordResult(a.word, false);
        recordResult(b.word, false);
        feedback("配对失败，记忆回放队列 +2", "bad");
        setTimeout(() => {
          a.revealed = false;
          b.revealed = false;
          m.revealed = [];
          m.lock = false;
          renderMemory();
        }, 620);
      }
    }

    function endMemory() {
      state.running = false;
      state.progress.xp += 45;
      state.progress.coins += 12;
      saveProgress();
      renderDashboard();
      renderWeakWords();
      sparkle(16);
      progressBar(100);
      arenaTitleEl.textContent = `Unit ${state.unit} · 记忆翻牌通关`;
      arenaSubEl.textContent = `总步数 ${state.memory.moves}`;
      feedback("记忆局完成：+45 XP +12 Coin", "good");
      log("记忆翻牌通关");
    }

    function buildMask(word) {
      return word
        .split("")
        .map((ch, idx) => {
          if (/\s|-|'|\./.test(ch)) return ch;
          if (idx === 0) return ch;
          return "_";
        })
        .join("");
    }

    function startBoss() {
      clearTimer();
      state.running = true;
      state.combo = 0;
      const pool = pickWords(unitPool(), Math.min(18, unitPool().length));
      state.boss = {
        hp: 150,
        maxHp: 150,
        heart: 3,
        queue: pool,
        idx: 0,
        current: null
      };
      arenaTitleEl.textContent = `Unit ${state.unit} · BOSS 拼写战`;
      arenaSubEl.textContent = "中文释义 -> 英文拼写。击穿 BOSS 血条。";
      renderBossTurn();
      log(`进入 BOSS 拼写战，词池 ${pool.length}`);
    }

    function renderBossTurn() {
      const b = state.boss;
      if (!b) return;
      if (b.hp <= 0) return endBoss(true);
      if (b.heart <= 0) return endBoss(false);
      if (b.idx >= b.queue.length) b.idx = 0;
      b.current = b.queue[b.idx++];
      const hpRate = (b.hp / b.maxHp) * 100;
      progressBar(hpRate);

      arenaBodyEl.innerHTML = `
        <div class="question-card">
          <div class="question-type">SPELLING BOSS</div>
          <p class="question-main">${b.current.zh}</p>
          <p class="question-sub">提示：${buildMask(b.current.en)}（长度 ${b.current.en.length}）</p>
        </div>
        <div class="battle-row">
          <div class="battle-card">
            <h4>你</h4>
            <div class="hp">${"❤".repeat(b.heart)}${"♡".repeat(3 - b.heart)}</div>
            <div style="margin-top:6px;font-size:0.85rem;color:var(--muted)">连击 x${state.combo}</div>
          </div>
          <div class="battle-card">
            <h4>BOSS</h4>
            <div class="bar"><i style="width:${hpRate}%"></i></div>
            <div style="margin-top:6px;font-size:0.85rem;color:var(--muted)">HP ${b.hp}/${b.maxHp}</div>
          </div>
        </div>
        <input class="input" id="spellInput" placeholder="输入完整英文拼写（回车提交）" autocomplete="off" />
        <div class="btn-row" style="margin-top:10px;">
          <button class="btn btn-primary" id="spellBtn">攻击</button>
          <button class="btn btn-light" id="skipBtn">跳过（掉 1 心）</button>
        </div>
      `;

      const input = document.getElementById("spellInput");
      const submit = document.getElementById("spellBtn");
      const skip = document.getElementById("skipBtn");
      input.focus();
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") handleBossAnswer();
      });
      submit.addEventListener("click", handleBossAnswer);
      skip.addEventListener("click", () => {
        state.boss.heart -= 1;
        state.combo = 0;
        feedback(`跳过：正确拼写是 ${state.boss.current.en}`, "bad");
        recordResult(state.boss.current, false);
        setTimeout(renderBossTurn, 620);
      });
    }

    function handleBossAnswer() {
      const input = document.getElementById("spellInput");
      if (!input || !state.boss || !state.boss.current) return;
      const ans = normalizeText(input.value);
      const right = normalizeText(state.boss.current.en);
      if (!ans) return;

      if (ans === right) {
        const crit = Math.random() < 0.25;
        const damage = 22 + Math.min(18, state.combo * 3) + (crit ? 14 : 0);
        state.boss.hp = Math.max(0, state.boss.hp - damage);
        recordResult(state.boss.current, true);
        feedback(`命中${crit ? " · 暴击" : ""}：-${damage} HP`, "good");
        log(`BOSS受击：${state.boss.current.en} -${damage}HP`);
      } else {
        state.boss.heart -= 1;
        state.combo = 0;
        recordResult(state.boss.current, false);
        feedback(`拼写错误：应为 ${state.boss.current.en}`, "bad");
        log(`BOSS回击：${state.boss.current.en}`);
      }
      setTimeout(renderBossTurn, 650);
    }

    function endBoss(win) {
      state.running = false;
      if (win) {
        state.progress.xp += 80;
        state.progress.coins += 25;
        saveProgress();
        renderDashboard();
        renderWeakWords();
        sparkle(24);
        arenaBodyEl.innerHTML = `
          <div class="question-card">
            <div class="question-type">BOSS DOWN</div>
            <p class="question-main">胜利！你击败了 Unit ${state.unit} BOSS。</p>
            <p class="question-sub">奖励：+80 XP，+25 Coin</p>
          </div>
        `;
        feedback("拼写战通关。建议切回闪电模式巩固速度。", "good");
        log("BOSS 拼写战胜利");
      } else {
        arenaBodyEl.innerHTML = `
          <div class="question-card">
            <div class="question-type">MISSION FAILED</div>
            <p class="question-main">挑战失败，BOSS 仍有 ${state.boss.hp} HP。</p>
            <p class="question-sub">先做“记忆翻牌”再回来复仇，效率更高。</p>
          </div>
        `;
        feedback("战败：错词已加入优先复习队列", "bad");
        log("BOSS 拼写战失败");
      }
      progressBar(win ? 100 : (state.boss.hp / state.boss.maxHp) * 100);
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function bindActions() {
      startBtn.addEventListener("click", () => {
        state.combo = 0;
        startMode();
      });

      nextBtn.addEventListener("click", () => {
        if (state.mode === "rush" && state.running) {
          clearTimer();
          state.locked = true;
          state.index += 1;
          renderRushQuestion();
        }
      });

      resetBtn.addEventListener("click", () => {
        if (!confirm("确认重置全部词汇进度和奖励吗？")) return;
        localStorage.removeItem(STORAGE_KEY);
        state.progress = loadProgress();
        state.combo = 0;
        renderDashboard();
        renderWeakWords();
        setArenaIntro();
        log("已重置全部进度");
      });
    }

    function init() {
      renderUnitSelector();
      renderModeSelector();
      renderModeHint();
      renderDashboard();
      renderWeakWords();
      setArenaIntro();
      bindActions();
      log("系统就绪：可开始英语词汇闯关");
    }

    init();
  </script>
</body>
</html>
