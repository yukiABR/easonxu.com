<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>英语词汇射击场 · Grade 8</title>
  <style>
    :root {
      --bg-a: #060a16;
      --bg-b: #101f45;
      --bg-c: #182f64;
      --text: #eaf2ff;
      --muted: #9fb3d7;
      --line: rgba(149, 182, 255, 0.32);
      --panel: rgba(10, 18, 42, 0.74);
      --panel-strong: rgba(12, 22, 49, 0.9);
      --cyan: #40e6ff;
      --pink: #ff6dc6;
      --violet: #9f8dff;
      --gold: #ffd667;
      --good: #48e890;
      --bad: #ff6d87;
      --shadow: 0 16px 42px rgba(3, 8, 22, 0.56);
      --r: 16px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      font-family: "STKaiti", "Kaiti SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background:
        radial-gradient(circle at 10% 12%, rgba(64, 230, 255, 0.2), transparent 28%),
        radial-gradient(circle at 86% 14%, rgba(159, 141, 255, 0.19), transparent 27%),
        radial-gradient(circle at 58% 84%, rgba(255, 109, 198, 0.16), transparent 34%),
        linear-gradient(145deg, var(--bg-a), var(--bg-b) 52%, var(--bg-c));
      padding: 14px;
      overflow-x: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      inset: -40vh -20vw;
      z-index: -2;
      pointer-events: none;
      background:
        repeating-linear-gradient(130deg,
          transparent 0,
          transparent 24px,
          rgba(150, 192, 255, 0.03) 24px,
          rgba(150, 192, 255, 0.03) 25px);
      animation: drift 24s linear infinite;
    }

    @keyframes drift {
      from { transform: translate3d(0, 0, 0); }
      to { transform: translate3d(-84px, -84px, 0); }
    }

    .app {
      max-width: 1240px;
      margin: 0 auto;
      display: grid;
      gap: 12px;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: var(--r);
      background: var(--panel);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .hero {
      position: relative;
      overflow: hidden;
      padding: 15px 16px;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }

    .hero::before {
      content: "";
      position: absolute;
      inset: -50% -30%;
      background:
        conic-gradient(from 0deg,
          rgba(64, 230, 255, 0.14),
          rgba(159, 141, 255, 0.1),
          rgba(255, 109, 198, 0.14),
          rgba(64, 230, 255, 0.14));
      filter: blur(26px);
      animation: spin 18s linear infinite;
      z-index: 0;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .hero-main,
    .hero-tags { position: relative; z-index: 1; }

    .hero h1 {
      margin: 0;
      font-size: clamp(1.2rem, 2.4vw, 1.95rem);
      letter-spacing: 0.04em;
    }

    .hero p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .tags {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 8px;
    }

    .tag {
      border: 1px solid rgba(64, 230, 255, 0.5);
      border-radius: 999px;
      padding: 5px 10px;
      color: var(--cyan);
      background: rgba(64, 230, 255, 0.12);
      font-size: 0.82rem;
      font-weight: 700;
    }

    .toolbar {
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .unit-chip,
    .btn,
    .select {
      border-radius: 11px;
      border: 1px solid transparent;
      background: rgba(14, 27, 57, 0.9);
      color: var(--text);
      font: inherit;
      padding: 8px 10px;
    }

    .unit-chip,
    .btn {
      cursor: pointer;
      transition: transform 0.13s ease, border-color 0.13s ease, box-shadow 0.13s ease;
    }

    .unit-chip:hover,
    .btn:hover {
      transform: translateY(-1px);
      border-color: rgba(131, 168, 255, 0.6);
      box-shadow: 0 8px 16px rgba(4, 11, 30, 0.4);
    }

    .unit-chip.active {
      border-color: rgba(255, 214, 103, 0.9);
      background: rgba(89, 68, 21, 0.52);
      color: #ffeab2;
      box-shadow: 0 0 0 1px rgba(255, 214, 103, 0.55) inset;
    }

    .btn-primary {
      border: none;
      color: #07111f;
      font-weight: 800;
      background: linear-gradient(135deg, #35e2ff, #8d95ff 50%, #ff6dc6);
    }

    .btn-secondary {
      border-color: rgba(130, 165, 255, 0.4);
      background: rgba(13, 25, 52, 0.84);
      color: #ddedff;
    }

    .btn-danger {
      border-color: rgba(255, 109, 135, 0.58);
      background: rgba(88, 22, 38, 0.56);
      color: #ffc8d3;
    }

    .select {
      border-color: rgba(131, 166, 255, 0.45);
      min-width: 120px;
    }

    .hint {
      font-size: 0.84rem;
      color: var(--muted);
    }

    .hud {
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(8, minmax(0, 1fr));
      gap: 8px;
    }

    .metric {
      border: 1px solid rgba(131, 166, 255, 0.3);
      background: rgba(11, 21, 46, 0.86);
      border-radius: 11px;
      min-height: 62px;
      padding: 8px;
    }

    .metric span {
      color: var(--muted);
      font-size: 0.76rem;
      display: block;
    }

    .metric strong {
      margin-top: 4px;
      display: block;
      font-size: 1.04rem;
      letter-spacing: 0.03em;
      font-family: "Futura", "Trebuchet MS", sans-serif;
    }

    .game-shell {
      padding: 10px;
      position: relative;
    }

    .game-wrap {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(129, 165, 255, 0.45);
      background: linear-gradient(160deg, rgba(8, 16, 36, 0.9), rgba(12, 24, 51, 0.9));
    }

    #gameCanvas {
      width: 100%;
      height: clamp(420px, 62vh, 640px);
      display: block;
      touch-action: none;
    }

    .prompt {
      position: absolute;
      left: 12px;
      right: 12px;
      top: 12px;
      border: 1px solid rgba(129, 166, 255, 0.45);
      border-radius: 12px;
      background: rgba(9, 18, 41, 0.78);
      backdrop-filter: blur(5px);
      padding: 10px 12px;
      pointer-events: none;
    }

    .prompt b {
      color: #cfe5ff;
      display: block;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .prompt strong {
      display: block;
      margin-top: 6px;
      font-size: clamp(1.05rem, 2.2vw, 1.45rem);
      line-height: 1.35;
      color: #f3f8ff;
      text-shadow: 0 3px 12px rgba(7, 14, 33, 0.58);
    }

    .prompt small {
      display: block;
      margin-top: 5px;
      color: var(--muted);
      font-size: 0.83rem;
    }

    .message {
      position: absolute;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      border-radius: 999px;
      background: rgba(9, 18, 41, 0.82);
      border: 1px solid rgba(131, 166, 255, 0.35);
      padding: 6px 12px;
      font-size: 0.84rem;
      color: var(--muted);
      max-width: calc(100% - 18px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .message.good { color: var(--good); border-color: rgba(72, 232, 144, 0.55); }
    .message.bad { color: var(--bad); border-color: rgba(255, 109, 135, 0.6); }

    .touch-bar {
      margin-top: 8px;
      display: none;
      gap: 8px;
      grid-template-columns: 1fr 1fr 1.2fr;
    }

    .touch-btn {
      border-radius: 11px;
      border: 1px solid rgba(130, 165, 255, 0.42);
      background: rgba(13, 25, 52, 0.9);
      color: #e7f1ff;
      padding: 12px;
      font: inherit;
      font-weight: 700;
      letter-spacing: 0.03em;
    }

    .touch-btn.fire {
      border-color: rgba(255, 214, 103, 0.6);
      background: rgba(86, 67, 21, 0.62);
      color: #ffe6a4;
    }

    .bottom {
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 10px;
    }

    .sub-panel {
      padding: 12px;
    }

    .sub-panel h3 {
      margin: 0 0 8px;
      font-size: 0.98rem;
      letter-spacing: 0.04em;
    }

    .weak-list {
      display: grid;
      gap: 8px;
      max-height: 230px;
      overflow: auto;
    }

    .weak-item {
      border-radius: 10px;
      border: 1px solid rgba(129, 165, 255, 0.35);
      background: rgba(10, 19, 42, 0.8);
      padding: 7px 8px;
      font-size: 0.83rem;
      line-height: 1.45;
    }

    .weak-item small {
      color: var(--muted);
      font-size: 0.75rem;
      display: block;
      margin-top: 2px;
    }

    .rules {
      font-size: 0.84rem;
      line-height: 1.6;
      color: var(--muted);
    }

    .rules b { color: #dbe9ff; }

    @media (max-width: 1020px) {
      .hud { grid-template-columns: repeat(4, minmax(0, 1fr)); }
      .bottom { grid-template-columns: 1fr; }
    }

    @media (max-width: 760px) {
      body { padding: 8px; }
      .hud { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .touch-bar { display: grid; }
      .hero h1 { letter-spacing: 0.02em; }
    }
  </style>
</head>
<body>
  <div class="app">
    <section class="panel hero">
      <div class="hero-main">
        <h1>英语词汇射击场 · Grade 8</h1>
        <p>目标：根据中文释义，射击正确英文词。越快越准，连击越高，记忆越牢。</p>
      </div>
      <div class="hero-tags">
        <div class="tags">
          <span class="tag">词汇射击</span>
          <span class="tag">错词优先复习</span>
          <span class="tag">炫光反馈</span>
        </div>
      </div>
    </section>

    <section class="panel toolbar">
      <div class="row" id="unitRow"></div>
      <div class="row">
        <select class="select" id="difficultySel">
          <option value="easy">难度：Easy</option>
          <option value="normal" selected>难度：Normal</option>
          <option value="hard">难度：Hard</option>
        </select>
        <button class="btn btn-primary" id="startBtn">开始战斗</button>
        <button class="btn btn-secondary" id="pauseBtn">暂停</button>
        <button class="btn btn-danger" id="resetBtn">重置进度</button>
      </div>
      <div class="hint" id="hint">键盘：A/D 或 ←/→ 移动，空格发射。移动端可用下方按钮。</div>
    </section>

    <section class="panel hud" id="hud"></section>

    <section class="panel game-shell">
      <div class="game-wrap">
        <canvas id="gameCanvas"></canvas>
        <div class="prompt">
          <b id="promptType">READY</b>
          <strong id="promptMain">点击“开始战斗”</strong>
          <small id="promptSub">系统会按记忆曲线抽词，错词会更频繁出现。</small>
        </div>
        <div class="message" id="message"></div>
      </div>
      <div class="touch-bar">
        <button class="touch-btn" id="touchLeft">左移</button>
        <button class="touch-btn" id="touchRight">右移</button>
        <button class="touch-btn fire" id="touchFire">发射</button>
      </div>
    </section>

    <div class="bottom">
      <section class="panel sub-panel">
        <h3>错词雷达</h3>
        <div class="weak-list" id="weakList"></div>
      </section>
      <section class="panel sub-panel">
        <h3>玩法说明</h3>
        <div class="rules">
          <div><b>1.</b> 顶部提示给出中文释义，你要射击对应的英文目标。</div>
          <div><b>2.</b> 打中正确词：得分 + XP + 连击；打错或漏掉：掉血并进入错词队列。</div>
          <div><b>3.</b> 每局 20 题，血量归零或题目结束时结算。</div>
          <div><b>4.</b> 系统使用本地记忆模型：你越容易错的词，会更频繁出现。</div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const WORDS = [
      { unit: 1, en: "self-expression", zh: "自我表达" },
      { unit: 1, en: "creativity", zh: "创造力" },
      { unit: 1, en: "scissors", zh: "剪刀" },
      { unit: 1, en: "drama", zh: "戏剧" },
      { unit: 1, en: "acting", zh: "表演" },
      { unit: 1, en: "normal", zh: "正常的；典型的" },
      { unit: 1, en: "prefer ... to ...", zh: "更喜欢...而不是..." },
      { unit: 1, en: "pottery", zh: "陶器；陶艺" },
      { unit: 1, en: "rather than", zh: "而不是" },
      { unit: 1, en: "position", zh: "位置" },
      { unit: 1, en: "instrument", zh: "器具；仪器" },
      { unit: 1, en: "sculpture", zh: "雕塑" },
      { unit: 1, en: "sculptor", zh: "雕塑家" },
      { unit: 1, en: "landscape", zh: "风景" },
      { unit: 1, en: "master", zh: "大师；能手" },
      { unit: 1, en: "dynasty", zh: "朝代" },
      { unit: 1, en: "paint", zh: "绘画" },
      { unit: 1, en: "harmony", zh: "和谐" },
      { unit: 1, en: "path", zh: "小道" },
      { unit: 1, en: "ahead", zh: "在前方" },
      { unit: 1, en: "whoever", zh: "无论谁" },
      { unit: 1, en: "come across", zh: "偶然遇见；发现" },
      { unit: 1, en: "scare", zh: "使惊吓" },
      { unit: 1, en: "scared", zh: "害怕的" },
      { unit: 1, en: "vivid", zh: "生动的" },
      { unit: 1, en: "east", zh: "东；东方" },
      { unit: 1, en: "west", zh: "西；西方" },
      { unit: 1, en: "peaceful", zh: "安静的；宁静的" },

      { unit: 2, en: "discovery", zh: "发现" },
      { unit: 2, en: "ancient", zh: "古代的" },
      { unit: 2, en: "exploration", zh: "探索；勘查" },
      { unit: 2, en: "wheel", zh: "轮子" },
      { unit: 2, en: "economy", zh: "经济" },
      { unit: 2, en: "material", zh: "材料；原料" },
      { unit: 2, en: "war", zh: "战争" },
      { unit: 2, en: "excite", zh: "使兴奋" },
      { unit: 2, en: "illness", zh: "疾病" },
      { unit: 2, en: "habit", zh: "习惯" },
      { unit: 2, en: "hardly", zh: "几乎不" },
      { unit: 2, en: "totally", zh: "完全地" },
      { unit: 2, en: "telephone", zh: "电话" },
      { unit: 2, en: "tube", zh: "管子" },
      { unit: 2, en: "bone", zh: "骨头" },
      { unit: 2, en: "X-ray", zh: "X 光" },
      { unit: 2, en: "award", zh: "奖励" },
      { unit: 2, en: "sir", zh: "先生；爵士" },
      { unit: 2, en: "by accident", zh: "偶然；意外地" },
      { unit: 2, en: "mould", zh: "霉菌" },
      { unit: 2, en: "bacteria", zh: "细菌" },
      { unit: 2, en: "turn ... into", zh: "使...变成" },
      { unit: 2, en: "life-saving", zh: "救命的" },
      { unit: 2, en: "course", zh: "课程；进程" },
      { unit: 2, en: "treat", zh: "医治" },
      { unit: 2, en: "serious", zh: "严重的" },
      { unit: 2, en: "medical", zh: "医学的；医疗的" },
      { unit: 2, en: "volunteer", zh: "志愿做；志愿者" },
      { unit: 2, en: "keep in touch", zh: "保持联系" },
      { unit: 2, en: "independent", zh: "独立的" },
      { unit: 2, en: "responsible", zh: "负责的" },
      { unit: 2, en: "responsibility", zh: "责任" },
      { unit: 2, en: "value", zh: "价值" },
      { unit: 2, en: "account", zh: "账户" },
      { unit: 2, en: "bank", zh: "银行" },
      { unit: 2, en: "whatever", zh: "无论什么" },
      { unit: 2, en: "economist", zh: "经济学家" },
      { unit: 2, en: "society", zh: "社会" },
      { unit: 2, en: "trade", zh: "贸易；交易" },
      { unit: 2, en: "exchange", zh: "交换" },
      { unit: 2, en: "goods", zh: "商品；货品" },
      { unit: 2, en: "sample", zh: "样品" },
      { unit: 2, en: "cost", zh: "成本；花费" },
      { unit: 2, en: "even if", zh: "即使" },
      { unit: 2, en: "might", zh: "可能；可以" },
      { unit: 2, en: "complete", zh: "完整的；完成" },
      { unit: 2, en: "completely", zh: "完全地" },
      { unit: 2, en: "valuable", zh: "有价值的；宝贵的" },
      { unit: 2, en: "pie chart", zh: "饼形图" },
      { unit: 2, en: "percentage", zh: "百分率" },

      { unit: 3, en: "mall", zh: "购物商场" },
      { unit: 3, en: "sale", zh: "出售；销售" },
      { unit: 3, en: "payment", zh: "支付；付款" },
      { unit: 3, en: "cash", zh: "现金" },
      { unit: 3, en: "assistant", zh: "店员；助手" },
      { unit: 3, en: "deal", zh: "交易；协议" },
      { unit: 3, en: "bill", zh: "账单" },
      { unit: 3, en: "donate", zh: "捐赠" },
      { unit: 3, en: "pound", zh: "英镑；磅" },
      { unit: 3, en: "cheap", zh: "便宜的" },
      { unit: 3, en: "chocolate", zh: "巧克力" },
      { unit: 3, en: "pocket", zh: "衣袋；口袋" },
      { unit: 3, en: "pocket money", zh: "零花钱" },
      { unit: 3, en: "expectation", zh: "期待；预期" },
      { unit: 3, en: "budget", zh: "预算" },
      { unit: 3, en: "financial", zh: "财政的；金融的" },
      { unit: 3, en: "in short", zh: "总之；简言之" },
      { unit: 3, en: "account for", zh: "占（数量上比例）" },

      { unit: 4, en: "fashion", zh: "时尚" },
      { unit: 4, en: "trainers", zh: "运动鞋" },
      { unit: 4, en: "decoration", zh: "装饰品" },
      { unit: 4, en: "afford", zh: "买得起；承担得起" },
      { unit: 4, en: "changeable", zh: "易变的" },
      { unit: 4, en: "fashionable", zh: "流行的" },
      { unit: 4, en: "flowery", zh: "用花装饰的" },
      { unit: 4, en: "outfit", zh: "全套服装" },
      { unit: 4, en: "narrow", zh: "狭窄的" },
      { unit: 4, en: "baggy", zh: "宽松的" },
      { unit: 4, en: "advertising", zh: "广告业；广告活动" },
      { unit: 4, en: "advertisement", zh: "广告" },
      { unit: 4, en: "image", zh: "形象；印象" },
      { unit: 4, en: "influencer", zh: "有影响力的人" },
      { unit: 4, en: "pioneer", zh: "先锋；带头人" },
      { unit: 4, en: "jewellery", zh: "珠宝；首饰" },
      { unit: 4, en: "attract", zh: "吸引" },
      { unit: 4, en: "relaxed", zh: "放松的；自在的" },
      { unit: 4, en: "mention", zh: "提到" },
      { unit: 4, en: "grade", zh: "分数；等级" },
      { unit: 4, en: "interest", zh: "兴趣" },

      { unit: 5, en: "disaster", zh: "灾难" },
      { unit: 5, en: "flood", zh: "洪水" },
      { unit: 5, en: "earthquake", zh: "地震" },
      { unit: 5, en: "terrible", zh: "可怕的" },
      { unit: 5, en: "force", zh: "力量；迫使" },
      { unit: 5, en: "injury", zh: "伤害；损伤" },
      { unit: 5, en: "death", zh: "死亡" },
      { unit: 5, en: "destroy", zh: "摧毁；破坏" },
      { unit: 5, en: "injure", zh: "使受伤" },
      { unit: 5, en: "effect", zh: "影响；作用" },
      { unit: 5, en: "dollar", zh: "元（美元等）" },
      { unit: 5, en: "exam", zh: "考试" },
      { unit: 5, en: "typhoon", zh: "台风" },
      { unit: 5, en: "battery", zh: "电池" },
      { unit: 5, en: "case", zh: "具体情况；案例" },
      { unit: 5, en: "in case", zh: "以防；以防万一" },
      { unit: 5, en: "go off", zh: "（电）中断；响起" },
      { unit: 5, en: "pick up", zh: "增强；改善；收拾" },
      { unit: 5, en: "lock", zh: "锁住；锁" },
      { unit: 5, en: "anyway", zh: "不过；总之" },
      { unit: 5, en: "anybody", zh: "任何人" },
      { unit: 5, en: "low-lying", zh: "低洼的" },
      { unit: 5, en: "cancel", zh: "取消" },
      { unit: 5, en: "necessary", zh: "必要的" },
      { unit: 5, en: "electronic", zh: "电子的" },
      { unit: 5, en: "be careful of", zh: "小心；当心" },
      { unit: 5, en: "survive", zh: "幸存" },
      { unit: 5, en: "similar", zh: "相像的" },
      { unit: 5, en: "foam", zh: "泡沫" },
      { unit: 5, en: "rapid", zh: "迅速的" },
      { unit: 5, en: "rapidly", zh: "迅速地" },

      { unit: 6, en: "towards", zh: "朝；向" },
      { unit: 6, en: "nothing", zh: "没什么" },
      { unit: 6, en: "whether", zh: "是否" },
      { unit: 6, en: "get away", zh: "离开；逃离" },
      { unit: 6, en: "hotel", zh: "旅馆" },
      { unit: 6, en: "guard", zh: "警卫；看守" },
      { unit: 6, en: "urge", zh: "敦促；力劝" },
      { unit: 6, en: "super", zh: "超级的" },
      { unit: 6, en: "seaside", zh: "海边" },
      { unit: 6, en: "last", zh: "持续；最近的" },
      { unit: 6, en: "thunder", zh: "雷；雷声" },
      { unit: 6, en: "coast", zh: "海岸" },
      { unit: 6, en: "rise", zh: "上升；升高" },
      { unit: 6, en: "injured", zh: "受伤的" },
      { unit: 6, en: "rescue", zh: "营救；救援" },
      { unit: 6, en: "tent", zh: "帐篷" },
      { unit: 6, en: "confused", zh: "困惑的" },
      { unit: 6, en: "tool", zh: "工具" },
      { unit: 6, en: "knife", zh: "刀" },
      { unit: 6, en: "fork", zh: "叉子" },
      { unit: 6, en: "packet", zh: "密封小袋" },
      { unit: 6, en: "seed", zh: "种子" },
      { unit: 6, en: "dead", zh: "死的；枯萎的" },
      { unit: 6, en: "cheerleader", zh: "拉拉队队员" },
      { unit: 6, en: "yourself", zh: "你自己" },
      { unit: 6, en: "whenever", zh: "无论何时" },
      { unit: 6, en: "be mean to sb", zh: "对某人刻薄" },
      { unit: 6, en: "stare", zh: "盯着看" },
      { unit: 6, en: "hang", zh: "悬挂；吊" },
      { unit: 6, en: "hang out", zh: "常去某处" },
      { unit: 6, en: "dig", zh: "挖；掘" },
      { unit: 6, en: "neither", zh: "两者都不" },
      { unit: 6, en: "as if", zh: "好像；仿佛" },
      { unit: 6, en: "lie", zh: "躺；平躺" },
      { unit: 6, en: "rug", zh: "垫子；小地毯" },
      { unit: 6, en: "ache", zh: "疼痛" },
      { unit: 6, en: "joke", zh: "玩笑" },
      { unit: 6, en: "terribly", zh: "非常糟地；严重地" },
      { unit: 6, en: "finish", zh: "完成；结束" },
      { unit: 6, en: "over the moon", zh: "欣喜若狂" },
      { unit: 6, en: "especially", zh: "尤其；特别" },
      { unit: 6, en: "novel", zh: "小说" },
      { unit: 6, en: "magical", zh: "魔法的；神奇的" },
      { unit: 6, en: "cheerful", zh: "开朗的；乐观的" },
      { unit: 6, en: "bad-tempered", zh: "易怒的" },
      { unit: 6, en: "caring", zh: "关心他人的；体贴的" },
      { unit: 6, en: "doubtful", zh: "怀疑的；不确定的" },
      { unit: 6, en: "firm", zh: "坚定的；坚决的" }
    ].map((w, i) => ({ ...w, id: `${w.unit}-${i}-${w.en.toLowerCase()}` }));

    const STORE_KEY = "english_shooter_progress_v1";

    const DIFF = {
      easy: { speed: 36, drift: 12, fireCd: 210, time: 16, options: 5, bonus: 1 },
      normal: { speed: 52, drift: 16, fireCd: 170, time: 13, options: 5, bonus: 2 },
      hard: { speed: 68, drift: 20, fireCd: 140, time: 10, options: 6, bonus: 4 }
    };

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const unitRow = document.getElementById("unitRow");
    const difficultySel = document.getElementById("difficultySel");
    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const hint = document.getElementById("hint");
    const hud = document.getElementById("hud");
    const promptType = document.getElementById("promptType");
    const promptMain = document.getElementById("promptMain");
    const promptSub = document.getElementById("promptSub");
    const messageEl = document.getElementById("message");
    const weakList = document.getElementById("weakList");

    const touchLeft = document.getElementById("touchLeft");
    const touchRight = document.getElementById("touchRight");
    const touchFire = document.getElementById("touchFire");

    const state = {
      units: new Set([1]),
      difficulty: "normal",
      running: false,
      paused: false,
      over: false,
      score: 0,
      combo: 0,
      hp: 5,
      xpGain: 0,
      round: 20,
      done: 0,
      right: 0,
      wrong: 0,
      timeLeft: 0,
      queue: [],
      currentWord: null,
      targets: [],
      bullets: [],
      particles: [],
      stars: [],
      ship: { x: 0.5, y: 0.92, w: 34, h: 34 },
      key: { left: false, right: false },
      fireStamp: 0,
      nextStamp: 0,
      width: 1200,
      height: 720,
      progress: loadProgress(),
      lastTs: 0
    };

    function loadProgress() {
      try {
        const raw = localStorage.getItem(STORE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && parsed.wordStats) return parsed;
        }
      } catch (_) {}
      return {
        xp: 0,
        bestScore: 0,
        bestCombo: 0,
        totalRight: 0,
        totalWrong: 0,
        sessions: 0,
        wordStats: {}
      };
    }

    function saveProgress() {
      localStorage.setItem(STORE_KEY, JSON.stringify(state.progress));
    }

    function statOf(id) {
      const bag = state.progress.wordStats;
      if (!bag[id]) bag[id] = { right: 0, wrong: 0, box: 1, due: 0 };
      return bag[id];
    }

    function levelByXp(xp) {
      return Math.floor(xp / 260) + 1;
    }

    function dueWeight(word) {
      const st = statOf(word.id);
      const now = Date.now();
      const dueBonus = st.due <= now ? 3 : 0;
      const weak = st.wrong * 2.4 - st.right * 0.5;
      const boxBias = st.box <= 2 ? 4 : st.box >= 4 ? -0.3 : 0;
      return Math.max(0.35, 1 + dueBonus + weak + boxBias);
    }

    function weightedPick(pool, n) {
      const src = pool.slice();
      const out = [];
      while (src.length && out.length < n) {
        const total = src.reduce((s, w) => s + dueWeight(w), 0);
        let hit = Math.random() * total;
        let idx = 0;
        for (; idx < src.length; idx += 1) {
          hit -= dueWeight(src[idx]);
          if (hit <= 0) break;
        }
        out.push(src.splice(Math.min(idx, src.length - 1), 1)[0]);
      }
      return out;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function poolByUnits() {
      return WORDS.filter((w) => state.units.has(w.unit));
    }

    function pickDecoys(pool, correctId, n) {
      return shuffle(pool.filter((w) => w.id !== correctId).slice()).slice(0, n);
    }

    function nextDue(box) {
      const mins = [0, 3, 12, 60, 360, 1440];
      return Date.now() + mins[Math.max(1, Math.min(box, 5))] * 60000;
    }

    function recordWord(word, correct) {
      const st = statOf(word.id);
      if (correct) {
        st.right += 1;
        st.box = Math.min(5, st.box + 1);
        st.due = nextDue(st.box);
        state.progress.totalRight += 1;
      } else {
        st.wrong += 1;
        st.box = Math.max(1, st.box - 1);
        st.due = Date.now() + 120000;
        state.progress.totalWrong += 1;
      }
      saveProgress();
      renderHud();
      renderWeakList();
    }

    function setMessage(text, type = "") {
      messageEl.textContent = text;
      messageEl.className = `message ${type}`;
    }

    function renderUnitChips() {
      const units = [1, 2, 3, 4, 5, 6];
      unitRow.innerHTML = units.map((u) => `<button class="unit-chip ${state.units.has(u) ? "active" : ""}" data-u="${u}">Unit ${u}</button>`).join("");
      unitRow.querySelectorAll(".unit-chip").forEach((btn) => {
        btn.addEventListener("click", () => {
          const u = Number(btn.dataset.u);
          if (state.units.has(u) && state.units.size > 1) state.units.delete(u);
          else state.units.add(u);
          renderUnitChips();
          renderHud();
          renderWeakList();
          if (!state.running) setReadyPrompt();
        });
      });
    }

    function renderHud() {
      const lv = levelByXp(state.progress.xp);
      const pool = poolByUnits();
      const due = pool.filter((w) => statOf(w.id).due <= Date.now()).length;
      const acc = state.progress.totalRight + state.progress.totalWrong === 0
        ? 0
        : Math.round((state.progress.totalRight / (state.progress.totalRight + state.progress.totalWrong)) * 100);
      const metrics = [
        ["当前得分", state.score],
        ["连击", `x${state.combo}`],
        ["生命", `${state.hp}/5`],
        ["进度", `${state.done}/${state.round}`],
        ["等级", `Lv.${lv}`],
        ["总 XP", state.progress.xp],
        ["正确率", `${acc}%`],
        ["待复习", `${due}/${pool.length}`]
      ];
      hud.innerHTML = metrics.map(([k, v]) => `<div class="metric"><span>${k}</span><strong>${v}</strong></div>`).join("");
    }

    function renderWeakList() {
      const list = poolByUnits()
        .map((w) => {
          const st = statOf(w.id);
          const risk = st.wrong * 2 - st.right + (st.box <= 2 ? 3 : 0);
          return { w, st, risk };
        })
        .sort((a, b) => b.risk - a.risk)
        .slice(0, 12);

      weakList.innerHTML = list.map(({ w, st }) => {
        const total = st.right + st.wrong;
        const rate = total ? `${Math.round((st.right / total) * 100)}%` : "--";
        return `<div class="weak-item">${w.en}<small>${w.zh} · 记忆盒 ${st.box} · 正确率 ${rate}</small></div>`;
      }).join("");
    }

    function setReadyPrompt() {
      promptType.textContent = "READY";
      promptMain.textContent = "点击“开始战斗”进入词汇射击";
      const units = [...state.units].sort((a, b) => a - b).join(", ");
      promptSub.textContent = `当前单元：${units} · 词库 ${poolByUnits().length} 个。`;
    }

    function resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * ratio);
      canvas.height = Math.floor(rect.height * ratio);
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      state.width = rect.width;
      state.height = rect.height;
      if (!state.stars.length) {
        for (let i = 0; i < 90; i += 1) {
          state.stars.push({
            x: Math.random() * state.width,
            y: Math.random() * state.height,
            r: 0.6 + Math.random() * 1.4,
            tw: Math.random() * Math.PI * 2,
            v: 8 + Math.random() * 18
          });
        }
      }
    }

    function startRound() {
      const pool = poolByUnits();
      if (pool.length < 8) {
        setMessage("词库太少，至少选择一个完整单元。", "bad");
        return;
      }
      state.running = true;
      state.paused = false;
      state.over = false;
      state.score = 0;
      state.combo = 0;
      state.hp = 5;
      state.xpGain = 0;
      state.done = 0;
      state.wrong = 0;
      state.right = 0;
      state.targets = [];
      state.bullets = [];
      state.particles = [];
      state.queue = weightedPick(pool, Math.min(state.round, pool.length));
      if (state.queue.length < state.round) {
        const fill = shuffle(pool.slice()).slice(0, state.round - state.queue.length);
        state.queue.push(...fill);
      }
      state.progress.sessions += 1;
      saveProgress();
      pauseBtn.textContent = "暂停";
      setMessage("进入战斗状态", "good");
      nextQuestion();
      renderHud();
    }

    function nextQuestion() {
      if (state.hp <= 0) {
        return finishRound(false);
      }
      if (state.done >= state.round || state.done >= state.queue.length) {
        return finishRound(true);
      }

      const diff = DIFF[state.difficulty];
      state.currentWord = state.queue[state.done];
      state.timeLeft = diff.time;
      state.targets = [];
      state.bullets = [];
      state.nextStamp = 0;

      const pool = poolByUnits();
      const decoys = pickDecoys(pool, state.currentWord.id, diff.options - 1);
      const options = shuffle([state.currentWord, ...decoys]);
      const slot = state.width / (options.length + 1);
      options.forEach((w, i) => {
        const textLen = w.en.length;
        const r = Math.max(30, Math.min(44, 44 - Math.floor(textLen / 8)));
        state.targets.push({
          word: w,
          correct: w.id === state.currentWord.id,
          x: slot * (i + 1) + (Math.random() * 22 - 11),
          y: -40 - Math.random() * 140,
          r,
          speed: diff.speed + Math.random() * 20,
          drift: (Math.random() > 0.5 ? 1 : -1) * (diff.drift + Math.random() * 10),
          seed: Math.random() * Math.PI * 2
        });
      });

      promptType.textContent = "SHOOT THE RIGHT WORD";
      promptMain.textContent = state.currentWord.zh;
      promptSub.textContent = `第 ${state.done + 1}/${state.round} 题 · 射击对应英文词`; 
      renderHud();
    }

    function finishRound(cleared) {
      state.running = false;
      state.over = true;
      state.targets = [];
      state.bullets = [];
      state.progress.bestScore = Math.max(state.progress.bestScore, state.score);
      state.progress.bestCombo = Math.max(state.progress.bestCombo, state.combo);
      state.progress.xp += state.xpGain;
      saveProgress();
      renderHud();
      renderWeakList();
      if (cleared) {
        promptType.textContent = "MISSION CLEAR";
        promptMain.textContent = `通关完成！总分 ${state.score}`;
        promptSub.textContent = `本轮获得 XP ${state.xpGain}，正确 ${state.right}，错误 ${state.wrong}`;
        setMessage("通关成功，建议切到更高难度。", "good");
      } else {
        promptType.textContent = "MISSION FAILED";
        promptMain.textContent = `生命耗尽，得分 ${state.score}`;
        promptSub.textContent = `本轮获得 XP ${state.xpGain}，正确 ${state.right}，错误 ${state.wrong}`;
        setMessage("挑战失败，错词已进入优先复习。", "bad");
      }
    }

    function fire() {
      if (!state.running || state.paused || state.over) return;
      const now = performance.now();
      if (now - state.fireStamp < DIFF[state.difficulty].fireCd) return;
      state.fireStamp = now;
      state.bullets.push({ x: state.ship.x * state.width, y: state.ship.y * state.height - 20, vy: 540, r: 4 });
      burst(state.ship.x * state.width, state.ship.y * state.height - 18, 4, "#40e6ff");
    }

    function burst(x, y, n, color) {
      for (let i = 0; i < n; i += 1) {
        const a = (Math.PI * 2 * i) / n + Math.random() * 0.4;
        const sp = 40 + Math.random() * 90;
        state.particles.push({
          x, y,
          vx: Math.cos(a) * sp,
          vy: Math.sin(a) * sp,
          life: 0.5 + Math.random() * 0.5,
          color
        });
      }
    }

    function handleTargetHit(tIdx, bIdx) {
      const t = state.targets[tIdx];
      state.bullets.splice(bIdx, 1);
      state.targets.splice(tIdx, 1);

      if (t.correct) {
        const gain = 16 + state.combo * 3 + DIFF[state.difficulty].bonus;
        state.score += gain;
        state.xpGain += Math.max(4, Math.floor(gain / 2));
        state.combo += 1;
        state.right += 1;
        state.done += 1;
        recordWord(state.currentWord, true);
        setMessage(`命中 +${gain} 分 · 连击 x${state.combo}`, "good");
        burst(t.x, t.y, 14, "#48e890");
        state.nextStamp = performance.now() + 360;
      } else {
        state.hp -= 1;
        state.wrong += 1;
        state.combo = 0;
        recordWord(state.currentWord, false);
        setMessage(`误击：${t.word.en}（-${1}生命）`, "bad");
        burst(t.x, t.y, 10, "#ff6d87");
        if (state.hp <= 0) {
          finishRound(false);
          return;
        }
        const pool = poolByUnits();
        const [replacement] = pickDecoys(pool, state.currentWord.id, 1);
        if (replacement) {
          state.targets.push({
            word: replacement,
            correct: false,
            x: 60 + Math.random() * (state.width - 120),
            y: -40,
            r: 34,
            speed: DIFF[state.difficulty].speed + Math.random() * 20,
            drift: (Math.random() > 0.5 ? 1 : -1) * (DIFF[state.difficulty].drift + Math.random() * 10),
            seed: Math.random() * Math.PI * 2
          });
        }
      }
      renderHud();
    }

    function update(dt, ts) {
      if (!state.running || state.paused || state.over) return;

      if (state.nextStamp && ts >= state.nextStamp) {
        nextQuestion();
      }

      const moveSpeed = 0.62 * dt;
      if (state.key.left) state.ship.x -= moveSpeed;
      if (state.key.right) state.ship.x += moveSpeed;
      state.ship.x = Math.max(0.06, Math.min(0.94, state.ship.x));

      state.timeLeft -= dt;
      if (state.timeLeft <= 0 && !state.nextStamp) {
        state.hp -= 1;
        state.wrong += 1;
        state.combo = 0;
        recordWord(state.currentWord, false);
        setMessage(`超时：${state.currentWord.en}（-${1}生命）`, "bad");
        if (state.hp <= 0) {
          finishRound(false);
          return;
        }
        state.done += 1;
        state.nextStamp = ts + 320;
      }

      for (let i = state.bullets.length - 1; i >= 0; i -= 1) {
        const b = state.bullets[i];
        b.y -= b.vy * dt;
        if (b.y < -20) state.bullets.splice(i, 1);
      }

      for (let i = state.targets.length - 1; i >= 0; i -= 1) {
        const t = state.targets[i];
        t.y += t.speed * dt;
        t.x += Math.sin(ts * 0.0012 + t.seed) * t.drift * dt;
        t.x = Math.max(t.r + 2, Math.min(state.width - t.r - 2, t.x));

        if (t.y - t.r > state.height) {
          state.targets.splice(i, 1);
          if (t.correct) {
            state.hp -= 1;
            state.wrong += 1;
            state.combo = 0;
            recordWord(state.currentWord, false);
            setMessage(`漏掉正确词：${state.currentWord.en}`, "bad");
            if (state.hp <= 0) return finishRound(false);
            state.done += 1;
            state.nextStamp = ts + 300;
          }
          continue;
        }

        for (let j = state.bullets.length - 1; j >= 0; j -= 1) {
          const b = state.bullets[j];
          const dx = b.x - t.x;
          const dy = b.y - t.y;
          const rr = b.r + t.r;
          if (dx * dx + dy * dy <= rr * rr) {
            handleTargetHit(i, j);
            break;
          }
        }
      }

      for (let i = state.particles.length - 1; i >= 0; i -= 1) {
        const p = state.particles[i];
        p.life -= dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.98;
        p.vy *= 0.98;
        if (p.life <= 0) state.particles.splice(i, 1);
      }
    }

    function drawTextInBubble(text, x, y, r) {
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#f0f6ff";
      const max = r * 1.6;
      let size = 15;
      ctx.font = `700 ${size}px Trebuchet MS, Arial, sans-serif`;
      while (size > 10 && ctx.measureText(text).width > max) {
        size -= 1;
        ctx.font = `700 ${size}px Trebuchet MS, Arial, sans-serif`;
      }

      const words = text.split(" ");
      const lines = [];
      let line = "";
      for (const w of words) {
        const test = line ? `${line} ${w}` : w;
        if (ctx.measureText(test).width <= max || !line) line = test;
        else {
          lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);

      const shown = lines.slice(0, 2);
      const lh = Math.max(12, size + 1);
      const baseY = y - ((shown.length - 1) * lh) / 2;
      shown.forEach((ln, i) => ctx.fillText(ln, x, baseY + i * lh));
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, state.width, state.height);

      const g = ctx.createLinearGradient(0, 0, 0, state.height);
      g.addColorStop(0, "rgba(7,16,34,0.95)");
      g.addColorStop(1, "rgba(8,22,50,0.95)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, state.width, state.height);

      state.stars.forEach((s) => {
        s.y += s.v * 0.012;
        if (s.y > state.height + 2) s.y = -2;
        const a = 0.35 + Math.sin(performance.now() * 0.001 + s.tw) * 0.2;
        ctx.fillStyle = `rgba(210,230,255,${a})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      });

      for (let i = 0; i < 9; i += 1) {
        const y = (state.height / 9) * i;
        ctx.strokeStyle = "rgba(120,155,230,0.09)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(state.width, y);
        ctx.stroke();
      }

      state.targets.forEach((t) => {
        const bubble = ctx.createRadialGradient(t.x - t.r * 0.3, t.y - t.r * 0.4, t.r * 0.2, t.x, t.y, t.r);
        bubble.addColorStop(0, "rgba(202, 226, 255, 0.96)");
        bubble.addColorStop(0.45, "rgba(84, 133, 226, 0.9)");
        bubble.addColorStop(1, "rgba(43, 72, 145, 0.95)");
        ctx.fillStyle = bubble;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(233,245,255,0.64)";
        ctx.lineWidth = 1.2;
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath();
        ctx.arc(t.x - t.r * 0.35, t.y - t.r * 0.35, t.r * 0.22, 0, Math.PI * 2);
        ctx.fill();

        drawTextInBubble(t.word.en, t.x, t.y, t.r);
      });

      state.bullets.forEach((b) => {
        ctx.fillStyle = "#46edff";
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(118,247,255,0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(b.x, b.y + 8);
        ctx.lineTo(b.x, b.y + 20);
        ctx.stroke();
      });

      state.particles.forEach((p) => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });

      const sx = state.ship.x * state.width;
      const sy = state.ship.y * state.height;
      ctx.save();
      ctx.translate(sx, sy);
      ctx.shadowBlur = 16;
      ctx.shadowColor = "rgba(64,230,255,0.8)";
      const shipGrad = ctx.createLinearGradient(-18, -12, 18, 14);
      shipGrad.addColorStop(0, "#42e9ff");
      shipGrad.addColorStop(0.55, "#9f8dff");
      shipGrad.addColorStop(1, "#ff6dc6");
      ctx.fillStyle = shipGrad;
      ctx.beginPath();
      ctx.moveTo(0, -18);
      ctx.lineTo(16, 14);
      ctx.lineTo(-16, 14);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(255,231,165,0.85)";
      ctx.fillRect(-3, 14, 6, 8);
      ctx.restore();

      if (!state.running) {
        ctx.fillStyle = "rgba(5,11,26,0.42)";
        ctx.fillRect(0, 0, state.width, state.height);
      }
    }

    function loop(ts) {
      if (!state.lastTs) state.lastTs = ts;
      const dt = Math.min(0.034, (ts - state.lastTs) / 1000);
      state.lastTs = ts;
      update(dt, ts);
      draw();
      requestAnimationFrame(loop);
    }

    function bindInput() {
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") state.key.left = true;
        if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") state.key.right = true;
        if (e.key === " ") {
          e.preventDefault();
          fire();
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") state.key.left = false;
        if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") state.key.right = false;
      });

      canvas.addEventListener("pointerdown", (e) => {
        const rect = canvas.getBoundingClientRect();
        state.ship.x = Math.max(0.06, Math.min(0.94, (e.clientX - rect.left) / rect.width));
        fire();
      });

      canvas.addEventListener("pointermove", (e) => {
        if (e.buttons !== 1) return;
        const rect = canvas.getBoundingClientRect();
        state.ship.x = Math.max(0.06, Math.min(0.94, (e.clientX - rect.left) / rect.width));
      });

      touchLeft.addEventListener("pointerdown", () => { state.key.left = true; });
      touchLeft.addEventListener("pointerup", () => { state.key.left = false; });
      touchLeft.addEventListener("pointerleave", () => { state.key.left = false; });

      touchRight.addEventListener("pointerdown", () => { state.key.right = true; });
      touchRight.addEventListener("pointerup", () => { state.key.right = false; });
      touchRight.addEventListener("pointerleave", () => { state.key.right = false; });

      touchFire.addEventListener("pointerdown", fire);
    }

    function bindActions() {
      difficultySel.addEventListener("change", () => {
        state.difficulty = difficultySel.value;
        hint.textContent = `当前难度：${difficultySel.options[difficultySel.selectedIndex].text}。A/D 或 ←/→ 移动，空格发射。`;
      });

      startBtn.addEventListener("click", startRound);

      pauseBtn.addEventListener("click", () => {
        if (!state.running || state.over) return;
        state.paused = !state.paused;
        pauseBtn.textContent = state.paused ? "继续" : "暂停";
        setMessage(state.paused ? "已暂停" : "继续战斗", "");
      });

      resetBtn.addEventListener("click", () => {
        if (!confirm("确认清空本地学习进度吗？")) return;
        localStorage.removeItem(STORE_KEY);
        state.progress = loadProgress();
        state.score = 0;
        state.combo = 0;
        state.hp = 5;
        renderHud();
        renderWeakList();
        setReadyPrompt();
        setMessage("进度已重置", "");
      });
    }

    function init() {
      renderUnitChips();
      renderHud();
      renderWeakList();
      setReadyPrompt();
      bindInput();
      bindActions();
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      setMessage("准备就绪", "");
      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>
